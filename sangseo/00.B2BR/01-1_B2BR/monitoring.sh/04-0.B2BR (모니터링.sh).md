pdf에서 말하는 `Monitoring.sh`를 생성해서 아래 요구사항을 만족시켜야 한다.
![[00.born2beroot_번역#Monitoring.sh]]
# 관련 자료
***
• 운영 체제의 아키텍처와 커널 버전.
uname -a
• 물리적 프로세서의 수. 
grep "physical id" /proc/cpuinfo | sort -u | wc -l
• 가상 프로세서의 수.
grep -c processor /proc/cpuinfo
• 현재 서버에서 사용 가능한 RAM 및 사용률(%)입니다.
FREE_TOTAL=\`free -m | grep Mem | awk '{print $2}'\`
FREE_USED=\`free -m | grep Mem | awk '{print $3}'\`
echo $FREE_USED $FREE_TOTAL | awk '{printf("#Memory Usage: %d/%dMB (%.2f\%%)", $1, $2, $1/$2\*100)}'
• 현재 서버에서 사용 가능한 메모리와 활용률(%)입니다.
[[04-1.Disk_Usage]]
• 프로세서의 현재 활용률(%)입니다.
• 마지막 재부팅 날짜 및 시간.
• `LVM`이 활성 상태인지 여부.
• 활성 연결 수.
• 서버를 사용하는 사용자 수.
• 서버의 `IPv4` 주소 및 해당 MAC(미디어 액세스 제어) 주소.
• `sudo` 프로그램으로 실행되는 명령의 수.
## arch
***
```
arch
```
아키텍처가 x86_64이라는 것은 x86이라는 설계 방법에 의해 만들어진 64bit 버전 CPU라는 것이고, 그 CPU가 작동하도록 만들어진 컴퓨터 시스템이라는 것입니다.
64bit라는 것은 CPU가 처리하는 데이터의 최소 단위를 말합니다.
bit 수가 클수록 속도는 빨라지게 되는 것은 맞습니다.
해당 비트 수에 맞게 주변기기도 구성해야 하고 작동되는 프로그램이 지원도 해야 합니다.
현재 서버에 사용하는 아키텍처는 대부분 x86_64입니다.

## lscpu
***
lscpu는 /proc/cpuinfo에서 CPU 아키텍처의 정보를 수집합니다.
정보에는 CPU 수, 스레드, 코어, 소켓 및 NUMA(Non-Uniform Memory Access) 노드 등이 포함됩니다.
실제로는 요약된 정보를 출력한다.
**`cat /proc/cpuinfo`** 명령어를 이용하면 다 자세한 내용을 볼 수 있다.
CPU와 관련해서는 [이쪽](https://gabriel9.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-CPU-%EC%A0%95%EB%B3%B4-%EB%B0%8F-%EC%82%AC%EC%9A%A9%EB%A5%A0-%ED%99%95%EC%9D%B8)이 잘 정리되어 있다.

## 메모리 사용량
[여기](https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%82%AC%EC%9A%A9%EB%A5%A0_%ED%99%95%EC%9D%B8)에 잘 정리되어 있다.
[여기도...](https://zetawiki.com/wiki/Bash_%EC%88%AB%EC%9E%90_%EA%B3%84%EC%82%B0)

메모리 사용량을 %로 나타내야 하는데 이러한 경우에는 [이쪽](https://zetawiki.com/wiki/Bash_%EC%88%AB%EC%9E%90_%EA%B3%84%EC%82%B0)링크를 참고하여 만들어보자